---
title: "Solving Rubik’s Cube with a robot hand"
source: "Unknown"
url: "https://openai.com/index/solving-rubiks-cube"
published: "2019-10-15T07:00:00.000Z"
category: "ai"
summary: "We’ve trained a pair of neural networks to solve the Rubik’s Cube with a human-like robot hand. The neural networks are trained entirely in simulation, using the same reinforcement learning code as OpenAI Five paired with a new technique called Automatic Domain Randomization (ADR). The system can handle situations it never saw during training, such as being prodded by a stuffed giraffe. This shows that reinforcement learning isn’t just a tool for virtual tasks, but can solve physical-world problems requiring unprecedented dexterity."
---
OpenAI

We’ve trained a pair of neural networks to solve the Rubik’s Cube with a human-like robot hand. The neural networks are trained entirely in simulation, using the same reinforcement learning code as [OpenAI Five⁠](https://openai.com/index/openai-five/) paired with a new technique called Automatic Domain Randomization (ADR). The system can handle situations it never saw during training, such as being prodded by a [stuffed giraffe⁠](https://openai.com/index/solving-rubiks-cube/#perturbations). This shows that reinforcement learning isn’t just a tool for virtual tasks, but can solve physical-world problems requiring unprecedented dexterity.

Human hands let us solve a wide variety of tasks. For the past 60 years of robotics, hard tasks which humans accomplish with their fixed pair of hands have required designing a custom robot for [each task⁠(opens in a new window)](https://www.guinnessworldrecords.com/world-records/fastest-robot-to-solve-a-rubiks-cube). As an alternative, people have spent [many decades trying to use general-purpose robotic hardware⁠(opens in a new window)](https://www.youtube.com/playlist?list=PLOXw6I10VTv8XX8Qnil18ilSaZvyQ4m2S), but with limited success due to their high degrees of freedom. In particular, the hardware we use here is not new—the robot hand we use has been around for the last 15 years—but the software approach is.

Since May 2017, we’ve been trying to train a human-like robotic hand to solve the [Rubik’s Cube⁠(opens in a new window)](https://en.wikipedia.org/wiki/Rubik%27s_Cube). We set this goal because we believe that successfully training such a robotic hand to do complex manipulation tasks lays the foundation for general-purpose robots. We solved the Rubik’s Cube in simulation in July 2017. But as of July 2018, we could only [manipulate a block⁠](https://openai.com/index/learning-dexterity/) on the robot. Now, we’ve reached our initial goal.

A full solve of the Rubik’s Cube. This video plays at real-time and was not edited in any way.

## Our approach

![A colorful collage of robotic arms](https://images.ctfassets.net/kftzwdyauwt9/cd53f310-7934-4b89-32c4ad0a62d5/70c5bdbc6b839586ada3b37f29f28883/dr.jpg?w=3840&q=90&fm=webp)

The biggest challenge we faced was to create environments in simulation diverse enough to capture the physics of the real world. Factors like friction, elasticity and dynamics are incredibly difficult to measure and model for objects as complex as Rubik’s Cubes or robotic hands and we found that domain randomization alone is not enough.

To overcome this, we developed a new method called _Automatic Domain Randomization_ (ADR), which endlessly generates progressively more difficult environments in simulation.[B](#citation-bottom-B) This frees us from having an accurate model of the real world, and enables the transfer of neural networks learned in simulation to be applied to the real world.

ADR starts with a single, nonrandomized environment, wherein a neural network learns to solve Rubik’s Cube. As the neural network gets better at the task and reaches a performance threshold, the amount of domain randomization is increased automatically. This makes the task harder, since the neural network must now learn to generalize to more randomized environments. The network keeps learning until it again exceeds the performance threshold, when more randomization kicks in, and the process is repeated.

One of the parameters we randomize is the size of the Rubik’s Cube (above). ADR begins with a fixed size of the Rubik’s Cube and gradually increases the randomization range as training progresses. We apply the same technique to all other parameters, such as the mass of the cube, the friction of the robot fingers, and the visual surface materials of the hand. The neural network thus has to learn to solve the Rubik’s Cube under all of those increasingly more difficult conditions.

Domain randomization required us to manually specify randomization ranges, which is difficult since too much randomization makes learning difficult but too little randomization hinders transfer to the real robot. ADR solves this by automatically expanding randomization ranges over time with no human intervention. ADR removes the need for domain knowledge and makes it simpler to apply our methods to new tasks. In contrast to manual domain randomization, ADR also keeps the task always challenging with training never converging.

We compared ADR to manual domain randomization on the block flipping task, where we already had a [strong baseline⁠](https://openai.com/index/learning-dexterity/). In the beginning ADR performs worse in terms of number of successes on the real robot. But as ADR increases the entropy, which is a measure of the complexity of the environment, the transfer performance eventually doubles over the baseline—without human tuning.

## Analysis

Using ADR, we are able to train neural networks in simulation that can solve the Rubik’s Cube on the real robot hand. This is because ADR exposes the network to an endless variety of randomized simulations. It is this exposure to complexity during training that prepares the network to transfer from simulation to the real world since it has to learn to quickly identify and adjust to whatever physical world it is confronted with.

To test the limits of our method, we experiment with a variety of perturbations while the hand is solving the Rubik’s Cube. Not only does this test for the robustness of our control network but also tests our vision network, which we here use to estimate the cube’s position and orientation.

We find that our system trained with ADR is surprisingly robust to perturbations even though we never trained with them: The robot can successfully perform most flips and face rotations under all tested perturbations, though not at peak performance.

We believe that [meta-learning⁠(opens in a new window)](https://en.wikipedia.org/wiki/Meta_learning_\(computer_science\)), or learning to learn, is an important prerequisite for building general-purpose systems, since it enables them to quickly adapt to changing conditions in their environments. The hypothesis behind ADR is that a memory-augmented networks combined with a sufficiently randomized environment leads to _emergent meta-learning_, where the network implements a learning algorithm that allows itself to rapidly adapt its behavior to the environment it is deployed in.[C](#citation-bottom-C)

To test this systematically, we measure the time to success per cube flip (rotating the cube such that a different color faces up) for our neural network under different perturbations, such as resetting the network’s memory, resetting the dynamics, or breaking a joint. We perform these experiments in simulation, which allows us to average performance over 10,000 trials in a controlled setting.

In the beginning, as the neural network successfully achieves more flips, each successive time to success decreases because the network learns to adapt. When perturbations are applied (vertical gray lines in the above chart), we see a spike in time to success. This is because the strategy the network is employing doesn’t work in the changed environment. The network then relearns about the new environment and we again see time to success decrease to the previous baseline.

We also measure failure probability and performed the same experiments for face rotations (rotating the top face 90 degrees clockwise or counterclockwise) and find the same pattern of adaptation.[D](#citation-bottom-D)

Visualizing our networks enables us to understand what they are storing in memory. This becomes increasingly important as the networks grow in complexity.

The memory of our neural network is visualized above. We use a [building block from the interpretability toolbox⁠(opens in a new window)](https://distill.pub/2018/building-blocks/), namely non-negative matrix factorization, to condense this high-dimensional vector into 6 groups and assign each a unique color. We then display the color of the currently dominant group for every timestep.

We find that each memory group has a semantically meaningful behavior associated with it. For example, we can tell by looking at only the dominant group of the network’s memory if it is about to spin the cube or rotate the top clockwise _before it happens_.

## Challenges

Solving the Rubik’s Cube with a robot hand is still not easy. Our method currently solves the Rubik’s Cube 20% of the time when applying a [maximally difficult scramble⁠(opens in a new window)](http://cube20.org/qtm/) that requires 26 face rotations. For simpler scrambles that require 15 rotations to undo, the success rate is 60%. When the Rubik’s Cube is dropped or a timeout is reached, we consider the attempt failed. However, our network is capable of solving the Rubik’s Cube from any initial condition. So if the cube is dropped, it is possible to put it back into the hand and continue solving.

We generally find that our neural network is much more likely to fail during the first few face rotations and flips. This is the case because the neural network needs to balance solving the Rubik’s Cube with adapting to the physical world during those early rotations and flips.

In order to benchmark our progress and make the problem tractable, we built and designed custom versions of cubes as stepping stones towards ultimately solving a regular Rubik’s Cube.[E](#citation-bottom-E)

![Openai Robotics Rubiks Prototypes](https://images.ctfassets.net/kftzwdyauwt9/d28a707a-a3b5-4325-fe750345c31c/6012421de5b956e985952f1239243fc8/openai-robotics-rubiks-prototypes.jpg?w=3840&q=90&fm=webp)

**Prototype**

**Position + orientation**

**Internal degrees of freedom (sensor)**

Locked cub

Vision

0 (No sensor)

Face cub

PhaseSpace

2 (PhaseSpace)

Full cube

PhaseSpace

6 (PhaseSpace)

Giiker cube

Vision

6 (Built-in sensors)

Regular Rubik’s Cube

Vision

6 (Vision)

## Next steps

We believe that human-level dexterity is on the path towards building general-purpose robots and we are excited to push forward in this direction.

_If you want to help make increasingly general AI systems, whether robotic or virtual,_ [_we’re hiring_⁠](https://openai.com/careers/#robotics)_!_

-   [Dactyl](https://openai.com/research/index/?tags=dactyl)
-   [Robotics](https://openai.com/research/index/?tags=robotics)
-   [Learning Paradigms](https://openai.com/research/index/?tags=learning-paradigms)
-   [Simulated Environments](https://openai.com/research/index/?tags=simulated-environments)

## Footnotes

1.  A
    
    We focus on the problems that are currently difficult for machines to master: perception and dexterous manipulation. We therefore train our neural networks to achieve the required face rotations and cube flips as generated by Kociemba’s algorithm.
    
2.  B
    
    Our work is strongly related to [POET⁠(opens in a new window)](https://arxiv.org/abs/1901.01753), which automatically generates 2D environments. However, our work learns a joint policy over all environments, which transfers to any newly generated environment.
    
3.  C
    
    More concretely, we hypothesize that a neural network with finite capacity trained on environments with unbounded complexity forces the network to learn a special-purpose learning algorithm since it cannot memorize solutions for each individual environment and there exists no single robust policy that works under all randomizations.
    
4.  D
    
    Please refer to our [paper⁠(opens in a new window)](https://arxiv.org/abs/1910.07113) for full results.
    
5.  E
    
    The only modification we made was cutting out a small piece of each center cublet’s colorful sticker. This was necessary to break [rotational symmetry⁠(opens in a new window)](https://en.wikipedia.org/wiki/Rotational_symmetry).
    

## Authors

[OpenAI](https://openai.com/news/?author=openai#results), [Ilge Akkaya](https://openai.com/news/?author=ilge-akkaya#results), [Marcin Andrychowicz](https://openai.com/news/?author=marcin-andrychowicz#results), [Maciek Chociej](https://openai.com/news/?author=maciek-chociej#results), [Mateusz Litwin](https://openai.com/news/?author=mateusz-litwin#results), [Bob McGrew](https://openai.com/news/?author=bob-mcgrew#results), [Arthur Petron](https://openai.com/news/?author=arthur-petron#results), [Alex Paino](https://openai.com/news/?author=alex-paino#results), [Matthias Plappert](https://openai.com/news/?author=matthias-plappert#results), [Glenn Powell](https://openai.com/news/?author=glenn-powell#results), [Raphael Ribas](https://openai.com/news/?author=raphael-ribas#results), [Jonas Schneider](https://openai.com/news/?author=jonas-schneider#results), [Nikolas Tezak](https://openai.com/news/?author=nikolas-tezak#results), [Jerry Tworek](https://openai.com/news/?author=jerry-tworek#results), [Peter Welinder](https://openai.com/news/?author=peter-welinder#results), [Lilian Weng](https://openai.com/news/?author=lilian-weng#results), [Qiming Yuan](https://openai.com/news/?author=qiming-yuan#results), [Wojciech Zaremba](https://openai.com/news/?author=wojciech-zaremba#results), [Lei Zhang](https://openai.com/news/?author=lei-zhang#results)

## Acknowledgments

Thanks to the following for feedback on drafts of this post and paper: Josh Achiam, Greg Brockman, Nick Cammarata, Jack Clark, Jeff Clune, Ruben D’Sa, Harri Edwards, David Farhi, Ken Goldberg, Leslie P. Kaelbling, Hyeonwoo Noh, Lerrel Pinto, John Schulman, Ilya Sutskever & Tao Xu.

Video: Peter Jordan (Director), Yvette Solis (Producer), Brooke Chan (Producer)

Editor: Ashley Pilipiszyn

Design: Justin Jay Wang & Ben Barry

Photography: Eric Haines
